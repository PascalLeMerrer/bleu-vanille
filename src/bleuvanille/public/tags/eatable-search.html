<eatable-search>

<div class="grid-5 navbar">
	<div>
		<input name="searchcriteria" onkeyup="{ search }"
			value="{ criteriaValue }">
	</div>
	<div>
		<a href="#null" onclick="{ searchIntern }">Trouver</i></a>
	</div>
	<div></div>
	<div></div>
	<div>
		<a href="#null" onclick="{ openModal }">Ajouter un élément</i></a>
	</div>
</div>

<table>
	<div class="grid-2">
		<div>
			<h2>{ getTitle() }</h2>
		</div>
		<div class="txtcenter">
			<pagination pager="{ pager }" loader="{ load }"></pagination>
		</div>
	</div>
	<thead>
		<tr>
			<th class="id-column">#</th>
			<th class="name-column">Nom</th>
			<th class="name-column">Parent</th>
			<th class="action-column"></th>
		</tr>
	</thead>
	<tbody>
		<tr if={neweatable } class="justcreated">
			<td>Création</td>
			<td>{ neweatable.name }</td>
			<td></td>
			<td class="action-column"></td>
		</tr>
		<tr each={foundEatable, index in foundEatables} >
			<td>{ index + 1 }</td>
			<td><editable-text bus="{ self.opts.bus }" callback="{ save }"
					property="name" id="{ foundEatable._id }"
					text="{ foundEatable.name }" type="text"></editable-text></td>
			<td><editable-text bus="{ self.opts.bus }" callback="{ saveParent }"
					property="foundEatable.parent.name" id="{ foundEatable._id }"
					text="{ foundEatable.parent.name }" type="text"></editable-text>
					</td>
			<td class="action-column"></td>
		</tr>
	</tbody>
</table>
<div class="txtcenter">
	<pagination pager="{ pager }" loader="{ load }"></pagination>
</div>
<script>
	var self = this
	self.criteriaValue = null
	self.foundEatables = null
	self.totalCount = 0
	self.notfound = false
	self.triggerTimeOutVar = null
	self.pager = {
		maxPage : 0,
		itemPerPage : 10,
		currentPage : 1
	}

	//Mounted events
	self.on('mount', function() {
		self.load()
	});

	this.opts.bus.on('setJustCreatedEatable', function(neweatable) {
		self.neweatable = neweatable
		self.update()
	});

	//Functions
	getTitle()
	{
		if (self.notfound) {
			return "Cette recherche ne correspond à aucun élément";
		}
		if (self.criteriaValue !== null) {
			return "Recherche \"" + self.criteriaValue + "\" : "
					+ self.totalCount + " élément"
					+ (self.totalCount > 1 ? 's' : '') + " trouvé"
					+ (self.totalCount > 1 ? 's' : '')
		}

		return self.totalCount + " élément" + (self.totalCount > 1 ? 's' : '')
				+ " indexé" + (self.totalCount > 1 ? 's' : '');
	}

	load(offset, limit)
	{
		if (offset === undefined) {
			offset = 0
		}

		if (limit === undefined) {
			limit = self.pager.itemPerPage
		}

		superagent
				.get('/search/fetch/all?offset=' + offset + '&limit=' + limit)
				.set('Content-Type', 'application/json; charset=UTF-8').set(
						'Accept', 'application/json').end(self.searchCallback)
	}

	// search eatable matching the criteria
	search(event)
	{
		//We disable the created eatable when doing the next search
		self.neweatable = null

		var criteriaValue = self.searchcriteria.value

		if (self.triggerTimeOutVar != null) {
			clearTimeout(self.triggerTimeOutVar)
			self.triggerTimeOutVar = null
		}

		if (criteriaValue.length > 4) {
			self.triggerTimeOutVar = setTimeout(self.searchIntern, 500);
		}

		if ((event.keyCode === 13 || event.keyCode === 32)
				& criteriaValue != undefined && criteriaValue.length > 1) {
			self.searchIntern()
		}
	}

	searchIntern(event)
	{
		self.triggerTimeOutVar = null
		var criteriaValue = self.searchcriteria.value
		self.criteriaValue = criteriaValue

		if (criteriaValue.startsWith("querystring")) {
			superagent.get('/search/query/' + criteriaValue.substring(12)).set(
					'Content-Type', 'application/json; charset=UTF-8').set(
					'Accept', 'application/json').end(self.searchCallback)
		} else {
			superagent.get('/search/' + criteriaValue).set('Content-Type',
					'application/json; charset=UTF-8').set('Accept',
					'application/json').end(self.searchCallback)
		}
	}

	// processes contact list loading response
	searchCallback(err, response)
	{
		if (response.ok) {
			self.foundEatables = response.body
			self.notfound = false
			self.totalCount = response.headers['x-total-count']
			self.pager.maxPage = Math.ceil(self.totalCount
					/ self.pager.itemPerPage)
			self.update()
		} else {
			self.foundEatables = []
			self.notfound = true
			self.opts.bus.trigger('displayError', "La recherche de "
					+ self.searchText + " a échouée.")
		}
	}

	// Saves the new value of a given user property
	save(id, property, value, callback)
	{
		superagent.patch("/" + id).send(
				'{"' + property + '":"' + value + '"}').set('Content-Type',
				'application/json; charset=UTF-8').end(callback)
	}

	// Saves the new value of a given user property
	saveParent(id, property, value, callback)
	{
		//Search for the parent from the value
		superagent.get('/search/' + value).set('Content-Type',
					'application/json; charset=UTF-8').set('Accept',
					'application/json').end(
							function (err, response) {
								if (response.ok) {
									foundParentEatables = response.body
									
									if (foundParentEatables != null && foundParentEatables.length > 0) {
										superagent.put('/' + id + '/parent/' + foundParentEatables[1]._key).set('Content-Type',
										'application/json; charset=UTF-8').set('Accept',
										'application/json').end(callback);
									} else {
										self.opts.bus.trigger('displayError', "Impossible de trouver le parent "
												+ value)								
									}
									self.update()
								} else {
									self.opts.bus.trigger('displayError', "Impossible de trouver le parent "
											+ value)
								}				
							}
					);
	}
	
	
	openModal()
	{
		var params = {
			"title" : "Ajouter un ingrédient"
		};

		self.opts.bus.trigger('openCreateEatableModal', params)
	}
</script>

<style>
.contact-table {
	width: 100%;
}

.id-column {
	width: 2em;
}

.name-column {
	width: 6em;
}

.action-column {
	width: 4em;
	text-align: center;
}

.justcreated {
	background-color: #EE9999;
}
</style>
</eatable-search>